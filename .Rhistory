par(pty="s")
plot(x[cumplen][1:100],y[cumplen][1:100],xlab = "",ylab="",xaxt='n',yaxt='n')
# Grafico todos los casos
par(pty="s")
plot(x[cumplen],y[cumplen],xlab = "",ylab="",xaxt='n',yaxt='n')
set.seed(1)
cant<-100
sim.BPP<-runifpoint(cant)
class(sim.BPP)
plot(sim.BPP)
set.seed(2)
sim.BPP<-runifpoint(cant)
plot(sim.BPP)
# muchas realizaciones
sim.BPP<-runifpoint(cant,nsim = 6)
plot(sim.BPP)
class(sim.BPP)
set.seed(1)
lambda<-100
sim.CSR<-rpoispp(lambda)
plot(sim.CSR,main = paste("Poisson Homogeneo lambda =",lambda))
set.seed(2)
lambda<-100
sim.CSR<-rpoispp(lambda)
plot(sim.CSR,main = paste("Poisson Homogeneo lambda =",lambda))
set.seed(1)
sim.INHa <- rpoispp(function(x,y) {800*(x-0.5)^2 + 800*(y-0.5)^2},nsim=1)
set.seed(1)
sim.INHa <- rpoispp(function(x,y) {800*(x-0.5)^2 + 800*(y-0.5)^2},nsim=1)
sim.INHb <- rpoispp(function(x,y) {200-800*(x-0.5)^2 + 200-800*(y-0.5)^2},nsim=1)
sim.INHa <- rpoispp(function(x,y) {800*(x-0.5)^2 + 800*(y-0.5)^2},nsim=1)
#require(devtools)
install_version("spatstat.core", version = "2.4.0", repos = "http://cran.us.r-project.org")
library(spatstat.core)
library(plotly)
# Graficacion
cuadri <- function(x, y){sqrt(x^2+y^2)/sqrt(8)} # Funcion de intensidad, toma valores entre 0 y 1
n<-10 # cant de datos
x <- y <- seq(0, 2, length= n)
xx<-rep(x,n)
yy<-rep(y,rep(n,n))
cbind(xx,yy) # grilla en el soporte
z <- outer(x, y, cuadri) # intensidad calculada en cada punto de grilla
u<-runif(n*n) # puntos aleatorios x y
graf<-persp(x, y, z,theta = 65,phi=25,zlab="u")
cumplen<-(u<z) # restricción para simular bajo la intensidad
points(trans3d(xx, yy, u,pmat=graf), col = 2+cumplen, pch = 16)
#  Simulacion
set.seed(1) # fijo la semilla
cant<-1000 # cant de obs
x<-runif(cant,0,2) # genero x entre 0 y 2
y<-runif(cant,0,2) # genero y entre 0 y 2
u<-runif(cant,0,1) # generu u entre 0 y 1
z<-cuadri(x,y) # evaluo en la funcion de intensidad
cumplen<-(u<z) # Restriccion
sum(cumplen) # cuantos quedan
# Grafico 100 casos
par(pty="s")
plot(x[cumplen][1:100],y[cumplen][1:100],xlab = "",ylab="",xaxt='n',yaxt='n')
# Grafico todos los casos
par(pty="s")
plot(x[cumplen],y[cumplen],xlab = "",ylab="",xaxt='n',yaxt='n')
set.seed(1)
cant<-100
sim.BPP<-runifpoint(cant)
class(sim.BPP)
plot(sim.BPP)
set.seed(2)
sim.BPP<-runifpoint(cant)
plot(sim.BPP)
# muchas realizaciones
sim.BPP<-runifpoint(cant,nsim = 6)
plot(sim.BPP)
class(sim.BPP)
set.seed(1)
lambda<-100
sim.CSR<-rpoispp(lambda)
plot(sim.CSR,main = paste("Poisson Homogeneo lambda =",lambda))
set.seed(2)
lambda<-100
sim.CSR<-rpoispp(lambda)
plot(sim.CSR,main = paste("Poisson Homogeneo lambda =",lambda))
set.seed(1)
sim.INHa <- rpoispp(function(x,y) {800*(x-0.5)^2 + 800*(y-0.5)^2},nsim=1)
#require(devtools)
install_version("spatstat.core", version = "2.3.0", repos = "http://cran.us.r-project.org")
library(spatstat.core)
# Graficacion
cuadri <- function(x, y){sqrt(x^2+y^2)/sqrt(8)} # Funcion de intensidad, toma valores entre 0 y 1
n<-10 # cant de datos
x <- y <- seq(0, 2, length= n)
xx<-rep(x,n)
yy<-rep(y,rep(n,n))
cbind(xx,yy) # grilla en el soporte
z <- outer(x, y, cuadri) # intensidad calculada en cada punto de grilla
u<-runif(n*n) # puntos aleatorios x y
graf<-persp(x, y, z,theta = 65,phi=25,zlab="u")
cumplen<-(u<z) # restricción para simular bajo la intensidad
points(trans3d(xx, yy, u,pmat=graf), col = 2+cumplen, pch = 16)
#  Simulacion
set.seed(1) # fijo la semilla
cant<-1000 # cant de obs
x<-runif(cant,0,2) # genero x entre 0 y 2
y<-runif(cant,0,2) # genero y entre 0 y 2
u<-runif(cant,0,1) # generu u entre 0 y 1
z<-cuadri(x,y) # evaluo en la funcion de intensidad
cumplen<-(u<z) # Restriccion
sum(cumplen) # cuantos quedan
# Grafico 100 casos
par(pty="s")
plot(x[cumplen][1:100],y[cumplen][1:100],xlab = "",ylab="",xaxt='n',yaxt='n')
# Grafico todos los casos
par(pty="s")
plot(x[cumplen],y[cumplen],xlab = "",ylab="",xaxt='n',yaxt='n')
set.seed(1)
cant<-100
sim.BPP<-runifpoint(cant)
class(sim.BPP)
plot(sim.BPP)
set.seed(2)
sim.BPP<-runifpoint(cant)
plot(sim.BPP)
# muchas realizaciones
sim.BPP<-runifpoint(cant,nsim = 6)
plot(sim.BPP)
class(sim.BPP)
set.seed(1)
lambda<-100
sim.CSR<-rpoispp(lambda)
plot(sim.CSR,main = paste("Poisson Homogeneo lambda =",lambda))
set.seed(2)
lambda<-100
sim.CSR<-rpoispp(lambda)
plot(sim.CSR,main = paste("Poisson Homogeneo lambda =",lambda))
set.seed(1)
sim.INHa <- rpoispp(function(x,y) {800*(x-0.5)^2 + 800*(y-0.5)^2},nsim=1)
install.packages("spatstat.geom")
install.packages("spatstat.geom")
library(spatstat.core)
library(plotly)
# Graficacion
cuadri <- function(x, y){sqrt(x^2+y^2)/sqrt(8)} # Funcion de intensidad, toma valores entre 0 y 1
n<-10 # cant de datos
x <- y <- seq(0, 2, length= n)
xx<-rep(x,n)
yy<-rep(y,rep(n,n))
cbind(xx,yy) # grilla en el soporte
z <- outer(x, y, cuadri) # intensidad calculada en cada punto de grilla
u<-runif(n*n) # puntos aleatorios x y
graf<-persp(x, y, z,theta = 65,phi=25,zlab="u")
cumplen<-(u<z) # restricción para simular bajo la intensidad
points(trans3d(xx, yy, u,pmat=graf), col = 2+cumplen, pch = 16)
#  Simulacion
set.seed(1) # fijo la semilla
cant<-1000 # cant de obs
x<-runif(cant,0,2) # genero x entre 0 y 2
y<-runif(cant,0,2) # genero y entre 0 y 2
u<-runif(cant,0,1) # generu u entre 0 y 1
z<-cuadri(x,y) # evaluo en la funcion de intensidad
cumplen<-(u<z) # Restriccion
sum(cumplen) # cuantos quedan
# Grafico 100 casos
par(pty="s")
plot(x[cumplen][1:100],y[cumplen][1:100],xlab = "",ylab="",xaxt='n',yaxt='n')
# Grafico todos los casos
par(pty="s")
plot(x[cumplen],y[cumplen],xlab = "",ylab="",xaxt='n',yaxt='n')
set.seed(1)
cant<-100
sim.BPP<-runifpoint(cant)
class(sim.BPP)
plot(sim.BPP)
set.seed(2)
sim.BPP<-runifpoint(cant)
plot(sim.BPP)
# muchas realizaciones
sim.BPP<-runifpoint(cant,nsim = 6)
plot(sim.BPP)
class(sim.BPP)
set.seed(1)
lambda<-100
sim.CSR<-rpoispp(lambda)
plot(sim.CSR,main = paste("Poisson Homogeneo lambda =",lambda))
set.seed(2)
lambda<-100
sim.CSR<-rpoispp(lambda)
plot(sim.CSR,main = paste("Poisson Homogeneo lambda =",lambda))
set.seed(1)
sim.INHa <- rpoispp(function(x,y) {800*(x-0.5)^2 + 800*(y-0.5)^2},nsim=1)
set.seed(1)
sim.INHa <- rpoispp(function(x,y) {800*(x-0.5)^2 + 800*(y-0.5)^2},nsim=1)
# El proceso CSR
sim.CSR
plot(sim.CSR)
# Quadrat Count
Q <- quadratcount(sim.CSR, nx= 4, ny=4)
plot(sim.CSR, pch=20, cols="grey70", main=NULL)  # Plot points
plot(Q, add=TRUE)  # Add quadrat grid
# Quadrat Density
Q.d <- intensity(Q)
plot(intensity(Q, image=TRUE), main=NULL, las=1)  # Plot density raster
plot(sim.CSR, pch=1, cex=0.01, col="grey", add=TRUE)  # Add points
QT <- quadrat.test(sim.CSR, nx=4, ny=4)
QT
library(spatstat.geom)
sim.INHa <- rpoispp(function(x,y) {800*(x-0.5)^2 + 800*(y-0.5)^2},nsim=1)
#require(devtools)
install_version("spatstat.core", version = "2.0.0", repos = "http://cran.us.r-project.org")
library(spatstat.core)
sim.INHa <- rpoispp(function(x,y) {800*(x-0.5)^2 + 800*(y-0.5)^2},nsim=1)
#require(devtools)
#install_version("spatstat.
#core", version = "2.0.0", repos = "http://cran.us.r-project.org")
library(spatstat.core)
library(plotly)
# Graficacion
cuadri <- function(x, y){sqrt(x^2+y^2)/sqrt(8)} # Funcion de intensidad, toma valores entre 0 y 1
n<-10 # cant de datos
x <- y <- seq(0, 2, length= n)
xx<-rep(x,n)
yy<-rep(y,rep(n,n))
cbind(xx,yy) # grilla en el soporte
z <- outer(x, y, cuadri) # intensidad calculada en cada punto de grilla
u<-runif(n*n) # puntos aleatorios x y
graf<-persp(x, y, z,theta = 65,phi=25,zlab="u")
cumplen<-(u<z) # restricción para simular bajo la intensidad
points(trans3d(xx, yy, u,pmat=graf), col = 2+cumplen, pch = 16)
#  Simulacion
set.seed(1) # fijo la semilla
cant<-1000 # cant de obs
x<-runif(cant,0,2) # genero x entre 0 y 2
y<-runif(cant,0,2) # genero y entre 0 y 2
u<-runif(cant,0,1) # generu u entre 0 y 1
z<-cuadri(x,y) # evaluo en la funcion de intensidad
cumplen<-(u<z) # Restriccion
sum(cumplen) # cuantos quedan
# Grafico 100 casos
par(pty="s")
plot(x[cumplen][1:100],y[cumplen][1:100],xlab = "",ylab="",xaxt='n',yaxt='n')
# Grafico todos los casos
par(pty="s")
plot(x[cumplen],y[cumplen],xlab = "",ylab="",xaxt='n',yaxt='n')
set.seed(1)
cant<-100
sim.BPP<-runifpoint(cant)
class(sim.BPP)
plot(sim.BPP)
set.seed(2)
sim.BPP<-runifpoint(cant)
plot(sim.BPP)
# muchas realizaciones
sim.BPP<-runifpoint(cant,nsim = 6)
plot(sim.BPP)
class(sim.BPP)
cant<-1000 # cant de obs
x<-runif(cant,0,2) # genero x entre 0 y 2
y<-runif(cant,0,2) # genero y entre 0 y 2
u<-runif(cant,0,1) # generu u entre 0 y 1
z<-cuadri(x,y) # evaluo en la funcion de intensidad
cumplen<-(u<z) # Restriccion
sum(cumplen) # cuantos quedan
# Grafico 100 casos
par(pty="s")
plot(x[cumplen][1:100],y[cumplen][1:100],xlab = "",ylab="",xaxt='n',yaxt='n')
# Grafico todos los casos
par(pty="s")
plot(x[cumplen],y[cumplen],xlab = "",ylab="",xaxt='n',yaxt='n')
sim.BPP<-runifpoint(cant)
plot(sim.BPP)
cant<-100
sim.BPP<-runifpoint(cant)
plot(sim.BPP)
sim.BPP<-runifpoint(cant)
plot(sim.BPP)
sim.BPP<-runifpoint(cant)
plot(sim.BPP)
sim.BPP<-runifpoint(cant)
plot(sim.BPP)
sim.BPP<-runifpoint(cant)
plot(sim.BPP)
sim.BPP<-runifpoint(cant)
plot(sim.BPP)
sim.BPP<-runifpoint(cant)
plot(sim.BPP)
sim.BPP<-runifpoint(cant)
plot(sim.BPP)
sim.BPP<-runifpoint(cant)
plot(sim.BPP)
sim.BPP<-runifpoint(cant)
plot(sim.BPP)
sim.BPP<-runifpoint(cant)
plot(sim.BPP)
sim.BPP<-runifpoint(cant)
plot(sim.BPP)
sim.BPP<-runifpoint(cant)
plot(sim.BPP)
set.seed(1)
lambda<-100
sim.CSR<-rpoispp(lambda)
plot(sim.CSR,main = paste("Poisson Homogeneo lambda =",lambda))
set.seed(2)
lambda<-100
sim.CSR<-rpoispp(lambda)
plot(sim.CSR,main = paste("Poisson Homogeneo lambda =",lambda))
sim.CSR
sim.CSR
rpoispp(lambda)
rpoispp(lambda)
rpoispp(lambda)
rpoispp(lambda)
rpoispp(lambda)
rpoispp(lambda)
rpoispp(lambda)
set.seed(1)
sim.INHa <- rpoispp(function(x,y) {800*(x-0.5)^2 + 800*(y-0.5)^2},nsim=1)
plot(sim.INHa)
set.seed(1)
sim.INHb <- rpoispp(function(x,y) {200-800*(x-0.5)^2 + 200-800*(y-0.5)^2},nsim=1)
plot(sim.INHb)
# a lo bruto
plot(sim.INHa,type="n",main="Superposición")
points(sim.INHa,col="blue")
points(sim.INHb,col="red")
# mas sofisticado
super<-superimpose(sim.INHa,sim.INHb) # superposicion de ppps
plot(super)
# El proceso CSR
sim.CSR
plot(sim.CSR)
# Quadrat Count
Q <- quadratcount(sim.CSR, nx= 4, ny=4)
plot(sim.CSR, pch=20, cols="grey70", main=NULL)  # Plot points
plot(Q, add=TRUE)  # Add quadrat grid
# Quadrat Density
Q.d <- intensity(Q)
plot(intensity(Q, image=TRUE), main=NULL, las=1)  # Plot density raster
plot(sim.CSR, pch=1, cex=0.01, col="grey", add=TRUE)  # Add points
Q
QT <- quadrat.test(sim.CSR, nx=4, ny=4)
QT
plot(QT)
Q.d
# Quadrat Count
Q <- quadratcount(sim.INHa, nx= 4, ny=4)
plot(sim.INHa, pch=20, cols="grey70", main=NULL)  # Plot points
plot(Q, add=TRUE)  # Add quadrat grid
# Quadrat Density
Q.d <- intensity(Q)
plot(intensity(Q, image=TRUE), main=NULL, las=1)  # Plot density raster
plot(sim.INHa, pch=1, cex=0.01, col="grey", add=TRUE)  # Add points
QT <- quadrat.test(sim.INHa, nx=4, ny=4)
QT
plot(QT)
par(mfrow=c(2,2))
par(mar=c(1,1,1,1))
set.seed(1)
inten<-30
disper<-0.02
mu<-10
sim.THO <- rThomas(inten,disper,mu)
plot(sim.THO,main=paste("Lambda=",inten,"Mu=",mu,"Sigma=",disper))
set.seed(1)
inten<-30
disper<-0.05
mu<-10
sim.THO <- rThomas(inten,disper,mu)
plot(sim.THO,main=paste("Lambda=",inten,"Mu=",mu,"Sigma=",disper))
set.seed(1)
inten<-10
disper<-0.02
mu<-30
sim.THO <- rThomas(inten,disper,mu)
plot(sim.THO,main=paste("Lambda=",inten,"Mu=",mu,"Sigma=",disper))
set.seed(1)
inten<-10
disper<-0.05
mu<-30
sim.THO <- rThomas(inten,disper,mu)
plot(sim.THO,main=paste("Lambda=",inten,"Mu=",mu,"Sigma=",disper))
par(mfrow=c(1,1))
par(mfrow=c(2,2))
par(mar=c(1,1,1,1))
set.seed(1)
delta<-0.01
sim.SSI <- rSSI(delta,100)
plot(sim.SSI,main=paste("n=100 delta=",delta))
set.seed(1)
delta<-0.05
sim.SSIa <- rSSI(delta,100)
plot(sim.SSIa,main=paste("n=100 delta=",delta))
set.seed(1)
delta<-0.1
sim.SSI <- rSSI(delta,100)
plot(sim.SSI,main=paste("n=100 delta=",delta))
set.seed(1)
delta<-0.2
sim.SSIb <- rSSI(delta,100)
plot(sim.SSIb,main=paste("n=100 delta=",delta))
#require(devtools)
#install_version("RandomFieldsUtils", version = "1.0.11", repos = "http://cran.us.r-project.org")
#install_version("RandomFields", version = "3.3.10", repos = "http://cran.us.r-project.org")
library(RandomFields)
library(RandomFieldsUtils)
# Defino el campo medio de la funcion de intensidad
m <- as.im(function(x, y){5 - 1.5 * (x - 0.5)^2 + 2 * (y - 0.5)^2}, W=owin())
class(m)
plot(m)
# Genero un Proceso de Cox Log Gausiano a partir del campo medio generado previamente
X <- rLGCP("gauss", m, var=0.15, scale =0.5)
# Grafico del campo aleatorio + la realizacion del proceso
plot(attr(X, "Lambda"))
points(X)
# Probemos tra ventana
#
ho <- owin(poly=list(list(x=c(0,2,1,0), y=c(0,0.3,1,0.8)),
list(x=c(0.6,0.4,0.4,0.6), y=c(0.2,0.2,0.4,0.4))))
m <- as.im(function(x, y){5 - 1.5 * (x - 0.5)^2 + 2 * (y - 0.5)^2}, W=ho)
plot(m)
par(mfrow=c(1,3))
plot(sim.CSR)
env.CSR <- envelope(sim.CSR, fun = Gest, nsim = 200,nrank=5)
plot(env.CSR)
env.CSR <- envelope(sim.CSR, fun = Fest, nsim = 200,nrank=5)
plot(env.CSR)
par(mfrow=c(1,1))
par(mfrow=c(1,3))
plot(sim.THO)
env.THO <- envelope(sim.THO, fun = Gest, nsim = 200,nrank=5)
plot(env.THO)
env.THO <- envelope(sim.THO, fun = Fest, nsim = 200,nrank=5)
plot(env.THO)
par(mfrow=c(1,1))
par(mfrow=c(1,3))
sim.SSI<-sim.SSIa
plot(sim.SSI)
env.SSI <- envelope(sim.SSI, fun = Gest, nsim = 200,nrank=5)
plot(env.SSI)
env.SSI <- envelope(sim.SSI, fun = Fest, nsim = 200,nrank=5)
plot(env.SSI)
par(mfrow=c(1,1))
par(mfrow=c(1,3))
plot(sim.CSR)
env.CSR <- envelope(sim.CSR, fun = Kest, nsim = 200,nrank=5)
plot(env.CSR)
env.CSR <- envelope(sim.CSR, fun = Lest, nsim = 200,nrank=5)
plot(env.CSR, . -r ~ r)
par(mfrow=c(1,1))
par(mfrow=c(1,3))
plot(sim.THO)
env.THO <- envelope(sim.THO, fun = Kest, nsim = 200,nrank=5)
plot(env.THO)
env.THO <- envelope(sim.THO, fun = Lest, nsim = 200,nrank=5)
plot(env.THO, . -r ~ r)
par(mfrow=c(1,1))
par(mfrow=c(1,3))
sim.SSI<-sim.SSIa
plot(sim.SSI)
env.SSI <- envelope(sim.SSI, fun = Kest, nsim = 200,nrank=5)
plot(env.SSI)
env.SSI <- envelope(sim.SSI, fun = Lest, nsim = 200,nrank=5)
plot(env.SSI, . -r ~ r)
par(mfrow=c(1,1))
par(mfrow=c(2,3))
par(mar=c(1,1,1,1))
plot(sim.CSR)
plot(sim.THO)
plot(sim.SSIb)
fryplot(sim.CSR)
fryplot(sim.THO)
fryplot(sim.SSIb)
par(mfrow=c(1,1))
library(manipulate)
x<-c(10,13,14)
GrafKDE<-function(h)
{
plot(density(x,bw=h,from=8,to=16),main=paste("Ventana =",h),ylab="Intensidad",ylim=c(0,0.8),lwd=3,xlab="")
points(x,c(0,0,0),pch=16,col="green")
n1<-function(x){dnorm(x,10,h)/3}
n2<-function(x){dnorm(x,13,h)/3}
n3<-function(x){dnorm(x,14,h)/3}
curve(n1, 7, 17, lwd=2, axes = FALSE, xlab = "", ylab = "",add=T,col="green",lty=3)
curve(n2, 7, 17, lwd=2, axes = FALSE, xlab = "", ylab = "",add=T,col="green",lty=3)
curve(n3, 7, 17, lwd=2, axes = FALSE, xlab = "", ylab = "",add=T,col="green",lty=3)
}
GrafKDE(0.5)
manipulate(GrafKDE(h=h),h=slider(0.2,2,step=0.1))
require(splancs)
# eleccion de ventana por diggle
mserw <- bw.diggle(sim.CSR)
bw <- as.numeric(mserw)*3
#
den.CSR<-density(sim.CSR,bw)
plot(den.CSR)
points(sim.CSR)
sim.CSR
plot(den.CSR)
points(sim.CSR)
library(manipulate)
x<-c(10,13,14)
GrafKDE<-function(h)
{
plot(density(x,bw=h,from=8,to=16),main=paste("Ventana =",h),ylab="Intensidad",ylim=c(0,0.8),lwd=3,xlab="")
points(x,c(0,0,0),pch=16,col="green")
n1<-function(x){dnorm(x,10,h)/3}
n2<-function(x){dnorm(x,13,h)/3}
n3<-function(x){dnorm(x,14,h)/3}
curve(n1, 7, 17, lwd=2, axes = FALSE, xlab = "", ylab = "",add=T,col="green",lty=3)
curve(n2, 7, 17, lwd=2, axes = FALSE, xlab = "", ylab = "",add=T,col="green",lty=3)
curve(n3, 7, 17, lwd=2, axes = FALSE, xlab = "", ylab = "",add=T,col="green",lty=3)
}
GrafKDE(0.5)
manipulate(GrafKDE(h=h),h=slider(0.2,2,step=0.1))
